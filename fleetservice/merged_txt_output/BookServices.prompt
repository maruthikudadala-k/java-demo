
You are a professional Java developer and test engineer.

Your task is to generate a **self-contained, safe, and fully compilable JUnit 5 test class** for the module defined below. The project strictly uses **Java 8** and **Mockito 2.x** ‚Äî follow this configuration without exception.

---

## ‚úÖ TEST GENERATION RULES

### 1Ô∏è‚É£ Scope of Testing
- ‚úÖ Only test **public methods and constructors** from the `CURRENT MODULE CODE`.
- ‚ùå Do **not** test private, protected, or package-private methods, fields, or internal logic.

### 2Ô∏è‚É£ Code Boundaries
- ‚úÖ Use only types defined in `CURRENT MODULE CODE` or `PROJECT-LEVEL IMPORTS`.
- ‚ùå Never define or assume the structure of missing models, enums, helpers, or external dependencies.

### 3Ô∏è‚É£ Input Handling
- ‚úÖ Treat all inputs as valid and well-formed.
- ‚úÖ Use safe defaults (e.g., `""`, `Collections.emptyList()`).
- ‚ùå Avoid `null` unless explicitly required.
- ‚ùå Do not test invalid or edge-case inputs unless the logic handles them.

### 4Ô∏è‚É£ Mockito 2.x Stubbing
- ‚úÖ Stub every used interaction explicitly.
- ‚úÖ Match method signatures exactly.
- ‚úÖ Avoid `null` return values unless handled.
- ‚ùå Do not rely on Mockito‚Äôs default returns or partial mocks.

### 5Ô∏è‚É£ Syntax & Structure
- ‚úÖ Use **JUnit 5** (`org.junit.jupiter.api.*`) and **Mockito 2.x** only.
- ‚úÖ Annotate with `@ExtendWith(MockitoExtension.class)`.
- ‚úÖ Use `@Mock` and `@InjectMocks` for dependency wiring.
- ‚úÖ Write clear, focused method names like `shouldReturnXWhenY`.
- ‚ùå Do not use `@BeforeEach` for `MockitoAnnotations.initMocks`.

### 6Ô∏è‚É£ Import Rules
- ‚úÖ Include **every required import** explicitly.
- ‚ùå Never use wildcard (`*`) or unused imports.

### 7Ô∏è‚É£ Behavior Verification
- ‚úÖ Only verify externally observable behavior or mock interactions.
- ‚ùå Never inspect or test private or internal state.

### 8Ô∏è‚É£ Servlet & Security Contexts
If the method under test (or any utility it calls) uses `HttpServletRequest` to extract a `Principal`, authentication details, or headers:

- ‚úÖ Use `MockHttpServletRequest` from `org.springframework.mock.web`.
- ‚úÖ If `request.getUserPrincipal()` is accessed:
  - Mock the exact principal **type actually used** in the module (e.g., `OAuth2Authentication`, `UsernamePasswordAuthenticationToken`, etc.).
  - If the logic chains calls (e.g., `getUserAuthentication().getDetails()`), mock and stub each intermediate object in that chain.
  - Return a minimal `Map<String, Object>` from `getDetails()` with **only required keys** ‚Äî do **not** assume domain-specific field names unless present in the source code.

- ‚úÖ If `request.getHeader(...)` is accessed, use `request.addHeader(key, value)` in the setup.
- ‚úÖ If `request.getAttribute(...)` is accessed, use `request.setAttribute(key, value)`.

- ‚ùå Do not hardcode field names or security class types unless already imported or used in the source.
- ‚ùå Do not partially stub or leave method calls unstubbed ‚Äî mock the full call chain accessed in the method.
- ‚ùå Do not assume any Spring Security context unless it appears explicitly in the current module.

### 9Ô∏è‚É£ Absolute Restrictions

* ‚ùå No reflection, guessing, or reconstruction of undefined types.
* ‚ùå No Java 9+ features.
* ‚ùå No output other than the test class code.

---

## ‚úÖ OUTPUT FORMAT

Output a single **fully compilable** JUnit 5 test class that includes:

* All required import statements
* JUnit 5 + Mockito 2.x compliant annotations
* Focused, deterministic test methods

‚ùå DO NOT output any explanation, comments, or additional content.

---
### üì¶ PROJECT-LEVEL IMPORTS

## 
---
### üß© CURRENT MODULE CODE

## // ===== Current file: src\main\java\com\carbo\fleet\services\BookServices.java =====
package com.carbo.fleet.services;

import org.springframework.stereotype.Service;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;

/**
 * Sample BookService for testing unit test generation
 * This service contains various method patterns that should generate comprehensive tests
 */
@Service
public class BookService {

    private List<Book> books = new ArrayList<>();

    /**
     * Adds a new book to the collection
     * @param book the book to add
     * @return the added book
     * @throws IllegalArgumentException if book is null or has invalid data
     */
    public Book addBook(Book book) {
        if (book == null) {
            throw new IllegalArgumentException("Book cannot be null");
        }
        if (book.getTitle() == null || book.getTitle().trim().isEmpty()) {
            throw new IllegalArgumentException("Book title cannot be empty");
        }
        if (book.getAuthor() == null || book.getAuthor().trim().isEmpty()) {
            throw new IllegalArgumentException("Book author cannot be empty");
        }
        if (book.getPrice() < 0) {
            throw new IllegalArgumentException("Book price cannot be negative");
        }

        book.setId(generateNewId());
        books.add(book);
        return book;
    }

    /**
     * Finds a book by ID
     * @param id the book ID
     * @return Optional containing the book if found, empty otherwise
     */
    public Optional<Book> findById(Long id) {
        if (id == null) {
            return Optional.empty();
        }
        return books.stream()
                .filter(book -> id.equals(book.getId()))
                .findFirst();
    }

    /**
     * Finds books by author
     * @param author the author name
     * @return list of books by the author
     */
    public List<Book> findByAuthor(String author) {
        if (author == null || author.trim().isEmpty()) {
            return new ArrayList<>();
        }
        return books.stream()
                .filter(book -> author.equalsIgnoreCase(book.getAuthor()))
                .toList();
    }

    /**
     * Updates a book's price
     * @param id the book ID
     * @param newPrice the new price
     * @return true if updated successfully, false if book not found
     * @throws IllegalArgumentException if price is negative
     */
    public boolean updatePrice(Long id, double newPrice) {
        if (newPrice < 0) {
            throw new IllegalArgumentException("Price cannot be negative");
        }
        
        Optional<Book> bookOpt = findById(id);
        if (bookOpt.isPresent()) {
            bookOpt.get().setPrice(newPrice);
            return true;
        }
        return false;
    }

    /**
   
     * @return total value
     */
    public double calculateTotalValue() {
        return books.stream()
                .mapToDouble(Book::getPrice)
                .sum();
    }

    /**
     * Gets books within a price range
     * @param minPrice minimum price (inclusive)
     * @param maxPrice maximum price (inclusive)
     * @return list of books in price range
     */
    public List<Book> getBooksByPriceRange(double minPrice, double maxPrice) {
        if (minPrice > maxPrice) {
            throw new IllegalArgumentException("Min price cannot be greater than max price");
        }
        
        return books.stream()
                .filter(book -> book.getPrice() >= minPrice && book.getPrice() <= maxPrice)
                .toList();
    }

    /**
     * Removes a book by ID
     * @param id the book ID to remove
     * @return true if removed, false if not found
     */
    public boolean removeBook(Long id) {
        if (id == null) {
            return false;
        }
        return books.removeIf(book -> id.equals(book.getId()));
    }

    /**
     * Gets all books
     * @return copy of all books
     */
    public List<Book> getAllBooks() {
        return new ArrayList<>(books);
    }

    /**
     * Checks if collection is empty
     * @return true if no books, false otherwise
     */
    public boolean isEmpty() {
        return books.isEmpty();
    }

    /**
     * Gets count of books
     * @return number of books
     */
    public int getBookCount() {
        return books.size();
    }

    private Long generateNewId() {
        return books.stream()
                .mapToLong(Book::getId)
                .max()
                .orElse(0L) + 1L;
    }

    
    public static class Book {
        private Long id;
        private String title;
        private String author;
        private double price;
        private String isbn;

        public Book() {}

        public Book(String title, String author, double price) {
            this.title = title;
            this.author = author;
            this.price = price;
        }

        public Book(String title, String author, double price, String isbn) {
            this.title = title;
            this.author = author;
            this.price = price;
            this.isbn = isbn;
        }

        // Getters and Setters
        public Long getId() { return id; }
        public void setId(Long id) { this.id = id; }

        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }

        public String getAuthor() { return author; }
        public void setAuthor(String author) { this.author = author; }

        public double getPrice() { return price; }
        public void setPrice(double price) { this.price = price; }

        public String getIsbn() { return isbn; }
        public void setIsbn(String isbn) { this.isbn = isbn; }

        @Override
        public String toString() {
            return "Book{" +
                    "id=" + id +
                    ", title='" + title + '\'' +
                    ", author='" + author + '\'' +
                    ", price=" + price +
                    ", isbn='" + isbn + '\'' +
                    '}';
        }
    }
}


